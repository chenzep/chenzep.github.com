<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Chenzep的博客]]></title>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2013-06-24T14:37:41+08:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[Chenzep]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[android日记保存]]></title>
    <link href="http://yoursite.com/blog/2013/06/22/android-log/"/>
    <updated>2013-06-22T12:11:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/06/22/android-log</id>
    <content type="html"><![CDATA[<ol>
<li><p>概述<br/>
 这几天在调试Android系统的LOG保存功能，把系统所有的LOG都保存到指定文件中，方便应用调试使用。查了网上的一些文章，处理方法就两种：
 a) 拦截<code>system\core\liblog\Logd_write.c</code>中的<code>__android_log_buf_write</code>函数。
 b) 参考或者直接调用<code>logcat</code>命令，把<code>/dev/log/...</code>块文件中的记录读取出来，并保存到文件中。
 测试了一下，发现这两种方法都有缺点:
 a) <code>__android_log_buf_write</code>函数是进程相关的，如果是通过条件变量来控制LOG保存与否，则条件变量只能在本进程中使用。也就是说不能控制系统或者其他应用的进程LOG的保存。还有一个就是权限问题，一般应用是无法把LOG保存到系统目录的。</p>

<p> b)通过<code>logcat</code>方法，就是保存文件大小方面不好控制,如果没有这方面的需求，这种方法还是可以用的。</p></li>
<li><p>代码流程<br/>
 简单概况下Log.v的函数的实现代码，详细的原理说明参考<a href="http://www.cnblogs.com/hoys/archive/2011/09/30/2196199.html">解读Android LOG机制的实现</a>。<br/>
 a. Log.v函数实现文件为：<code>frameworks\base\core\java\android\util\Log.java</code>。</p>

<pre><code> 函数直接调用JNI接口。

 public static int v(String tag, String msg, Throwable tr) {  
     return println_native(LOG_ID_MAIN, VERBOSE, tag, msg + '\n' + getStackTraceString(tr));
 }
</code></pre>

<p> b. JNI接口为：<code>android_util_Log_println_native</code>，实现文件是：<code>frameworks\base\core\jni\android_util_Log.cpp</code>，关键代码如下:</p>

<pre><code> static jint android_util_Log_println_native(JNIEnv* env, jobject clazz,
     jint bufID, jint priority, jstring tagObj, jstring msgObj)
 {
     ......
     #tag, msg是tagObj, msgObj转换后的const char*类型指针。
     int res = __android_log_buf_write(bufID, (android_LogPriority)priority, tag, msg);  
     ......
     return res;
 }
</code></pre>

<p> c. __android_log_buf_write函数的实现文件为:<code>system\core\liblog\Logd_write.c</code>,代码只是把相关数据封装在vec数组中，然后把数组传递给write_to_log函数，完整代码如下：</p>

<pre><code> int __android_log_buf_write(int bufID, int prio, const char *tag, const char *msg)
 {
     struct iovec vec[3];

     if (!tag)
         tag = "";

     /* XXX: This needs to go! */
     if (!strcmp(tag, "HTC_RIL") ||
         !strncmp(tag, "RIL", 3) || /* Any log tag with "RIL" as the prefix */
         !strcmp(tag, "AT") ||
         !strcmp(tag, "GSM") ||
         !strcmp(tag, "STK") ||
         !strcmp(tag, "CDMA") ||
         !strcmp(tag, "PHONE") ||
         !strcmp(tag, "SMS"))
             bufID = LOG_ID_RADIO;

     vec[0].iov_base   = (unsigned char *) &amp;prio;
     vec[0].iov_len    = 1;
     vec[1].iov_base   = (void *) tag;
     vec[1].iov_len    = strlen(tag) + 1;
     vec[2].iov_base   = (void *) msg;
     vec[2].iov_len    = strlen(msg) + 1;

     return write_to_log(bufID, vec, 3);
 }
</code></pre>

<p>  d. write_to_log最终会调用__write_to_log_kernel函数,函数就是往文件中写数据。</p>

<pre><code> static int __write_to_log_kernel(log_id_t log_id, struct iovec *vec, size_t nr)
 {
     ssize_t ret;
     int log_fd;

     if (/*(int)log_id &gt;= 0 &amp;&amp;*/ (int)log_id &lt; (int)LOG_ID_MAX) {
         log_fd = log_fds[(int)log_id];
     } else {
         return EBADF;
     }

     do {
         ret = log_writev(log_fd, vec, nr);
     } while (ret &lt; 0 &amp;&amp; errno == EINTR);

     return ret;
 }
</code></pre>

<p> e. log文件是一个字符设备文件，而且和普通的块设备还不太一样,有自己独立的实现代码，文件为<code>lichee\linux-3.0\drivers\staging\android\logger.c</code>。这里要说明的是实际的写函数:<code>logger_aio_write</code></p>

<pre><code> ssize_t logger_aio_write(struct kiocb *iocb, const struct iovec *iov,
      unsigned long nr_segs, loff_t ppos)
 {
     struct logger_log *log = file_get_log(iocb-&gt;ki_filp);
     size_t orig = log-&gt;w_off;
     struct logger_entry header;
     struct timespec now;
     ssize_t ret = 0;

     now = current_kernel_time();

     header.pid = current-&gt;tgid;
     header.tid = current-&gt;pid;
     header.sec = now.tv_sec;
     header.nsec = now.tv_nsec;
     header.len = min_t(size_t, iocb-&gt;ki_left, LOGGER_ENTRY_MAX_PAYLOAD);

     /* null writes succeed, return zero */
     if (unlikely(!header.len))
         return 0;

     mutex_lock(&amp;log-&gt;mutex);

     /*
      * Fix up any readers, pulling them forward to the first readable
      * entry after (what will be) the new write offset. We do this now
      * because if we partially fail, we can end up with clobbered log
      * entries that encroach on readable buffer.
      */
     fix_up_readers(log, sizeof(struct logger_entry) + header.len);

     #写入时间，进程等信息
     do_write_log(log, &amp;header, sizeof(struct logger_entry));
     #写入调试信息
     while (nr_segs-- &gt; 0) {
         size_t len;
         ssize_t nr;

         /* figure out how much of this vector we can keep */
         len = min_t(size_t, iov-&gt;iov_len, header.len - ret);

         /* write out this segment's payload */
         nr = do_write_log_from_user(log, iov-&gt;iov_base, len);
         if (unlikely(nr &lt; 0)) {
             log-&gt;w_off = orig;
             mutex_unlock(&amp;log-&gt;mutex);
             return nr;
         }

         iov++;
         ret += nr;
     }

     mutex_unlock(&amp;log-&gt;mutex);

     /* wake up any blocked readers */
     wake_up_interruptible(&amp;log-&gt;wq);

     return ret;
 }   
</code></pre></li>
<li><p>定制
 根据上面的代码流程，我们发现，在<code>logger_aio_write</code>添加保存LOG到文件中的功能是最好的，因为这里是内核层，不存在权限问题，也不存在进程共享的问题。
 比较头疼的是，在内核层，很多函数都无法使用，比如fopen,fread,&#8230;fclose,rename等。还好，内核层有对应的函数。
 下面是一些代码片段:</p>

<pre><code> const char *pri = iov[0].iov_base;

 const char *tag ;
 const char *msg;
 int taglen,msglen;
 const char *pCur;
 int ret;

 taglen = iov[1].iov_len;
 msglen = iov[2].iov_len;
 ret = copy_from_user(kernelBuffer,      iov[1].iov_base, taglen);
 if (ret != 0) goto leave;
 ret = copy_from_user(kernelBuffer + taglen,     iov[2].iov_base, msglen);
 if (ret != 0) goto leave;
 tag = kernelBuffer;
 msg = kernelBuffer + taglen;
 pCur = msg;

 if (saveFlag) {
     struct file *fileLog;
     mm_segment_t old_fs = get_fs();
     set_fs(KERNEL_DS);
     mutex_lock(&amp;s_filemutex);
     fileLog = filp_open(path,O_CREAT|O_WRONLY,0666);
     if (!(IS_ERR(fileLog))) {
         int pos;
         int n;
         struct rtc_time tm;
         /filterPriToChar实现参考system\core\liblog\logprint.c文件
         char priChar = filterPriToChar(*pri);
         rtc_time_to_tm(header.sec, &amp;tm);    

         n = sprintf(buffer,"%c %02d-%02d %02d:%02d:%02d.%03d %05d/%05d ",
             priChar, 
             tm.tm_mon+1,tm.tm_mday,tm.tm_hour,tm.tm_min,tm.tm_sec, header.nsec / 1000000, 
             header.pid, header.tid);

         #使用printf("%s",tag)有问题，Why.不太清楚是不是我那里搞错，还是内核不支持
         if (taglen &gt; 1) {
             memcpy(buffer + n, tag, taglen -1);
             n += taglen - 1;
         }else{
             memcpy(buffer + n, "(null)", 6);
             n += 6;
         }
         buffer[n++] = ' ';

         if (msglen &gt; 1) {
             memcpy(buffer + n, msg, msglen -1);
             n += msglen - 1;
         }else{
             memcpy(buffer + n, "(null)", 6);
             n += 6;
         }
         buffer[n++] = '\n';

         fileLog-&gt;f_op-&gt;llseek(fileLog,0,2);
         fileLog-&gt;f_op-&gt;write(fileLog,buffer,n,&amp;fileLog-&gt;f_pos);
         pos = fileLog-&gt;f_pos;
         filp_close(fileLog,0);
     }
     mutex_unlock(&amp;s_filemutex);
     set_fs(old_fs);
 }
 leave:
     ret = 0;
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android备忘录]]></title>
    <link href="http://yoursite.com/blog/2013/06/20/android-memo/"/>
    <updated>2013-06-20T16:43:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/06/20/android-memo</id>
    <content type="html"><![CDATA[<p>1.开机动画</p>

<pre><code>开机动画的相关文件在`android4.0\frameworks\base\cmds\bootanimation`目录下.  
主要函数式BootAnimation中的bool BootAnimation::movie()函数。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Octopress建Blog(高级篇)]]></title>
    <link href="http://yoursite.com/blog/2013/06/19/octopress-adv/"/>
    <updated>2013-06-19T11:53:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/06/19/octopress-adv</id>
    <content type="html"><![CDATA[<ol>
<li>准备

<ul>
<li><p>编码。octopress的配置文件如果包含有中文，则此文件必须使用无BOM的UTF-8编码，否则<code>rake generate</code>的时候会出错。 使用UltraEdit的<code>文件--&gt;另存为</code>可以把文件保存为无BOM的UTF-8编码格式。</p>

<p>  <img src="http://yoursite.com/pics/octopress_adv_encode.jpg" alt="" /></p></li>
</ul>
</li>
</ol>


<!-- more -->


<ol>
<li><p>常用设置
本来是想自己写的，但是发现网上有一篇整理的很好的文章，就不重复劳动了。文章链接如下：<br/>
 <a href="http://www.cnblogs.com/oec2003/archive/2013/05/31/3109577.html">http://www.cnblogs.com/oec2003/archive/2013/05/31/3109577.html</a></p></li>
<li><p>Disqus设置</p>

<ul>
<li>设置语言
  Setting&#8211;>General&#8211;>Language&#8211;>chinese
  <img src="http://yoursite.com/pics/octopress_adv_disqus_language.jpg" alt="" /></li>
<li>去掉广告
<img src="http://yoursite.com/pics/octopress_adv_disqus_justcomment.jpg" alt="" /></li>
</ul>
</li>
<li><p>关于More
 正确的书写应该如下，注意空格，很多网站就是空格错误，导致无效。</p>

<pre><code> &lt;!-- more --&gt;
</code></pre></li>
<li><p>修改代码区块的颜色
 Octopress默认的代码区块字体的颜色太暗，改明亮一下，修改<code>sass\partials\_syntax.scss</code>文件</p>

<pre><code> p, li {
   code {
     @extend .mono;
     display: inline-block;
     white-space: no-wrap;
     background: #fff;
     font-size: .8em;
     line-height: 1.5em;
     color: #888888; /* 原来是#555 */
     border: 1px solid #ddd;
     @include border-radius(.4em);
     padding: 0 .3em;
     margin: -1px 0;
   }
   pre code { font-size: 1em !important; background: none; border: none; }
 }
</code></pre></li>
<li><p>本地图片预览<br/>
 a. MarkdownPad2是支持图片预览功能的(好像要Pro版本?)。如果使用的本地图片，比如<code>![](/pics/1.jpg)</code>, 需要在Markdown文件的目录下存在<code>pics/1.jpg</code>图片，MarkdownPad2才能正确显示图片。因此，本地图片一rak般放到<code>octopress\source\_posts\pics</code>文件夹下。<br/>
 b. 为了避免使用<code>git add .</code>命令的时候把<code>pics</code>文件夹的图片也添加进入，我们需要添加一个<code>.gitignore</code>文件让git来忽略pics文件夹，文件的内容很简单,输入忽略的目录名称即可：<code>pics</code><br/>
 c. 加入了<code>.gitignore</code>文件之后，会导致<code>rake deploy</code>阶段出错，我们修改<code>octopress/Rakefile</code>文件，忽略对<code>.gitignore</code>文件的处理，修改如下:</p>

<pre><code>     desc "copy dot files for deployment"
     task :copydot, :source, :dest do |t, args|
       FileList["#{args.source}/**/.*"].exclude("**/.","**/..", "**/.DS_Store", "**/._*","**/.gitignore").each do |file|
         cp_r file, file.gsub(/#{args.source}/, "#{args.dest}") unless File.directory?(file)
       end
     end
</code></pre>

<p> d. 用MarkdownPad2编译好文件之后，运行<code>rake generate</code>,<code>rake preview</code>更新和启动预览，然后再浏览器输入<code>localhost:4000</code>，发现浏览页面的图片显示也不正确。这是因为<code>octopress\public</code>目录下没有对应的图片导致的。修改<code>octopress/Rakefile</code>文件，把<code>octopress\source\_posts\pics</code>目录的内容拷贝到<code>octopress\source</code>目录,然后jelly程序会把<code>octopress\source</code>目录的内容拷贝到<code>octopress\public</code>目录。修改如下：</p>

<pre><code> desc "Generate jekyll site"
 task :generate do
   raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
   puts "## Copy Pictures"
   cp_r "#{source_dir}/_posts/pics", "#{source_dir}"
   puts "## Generating Site with Jekyll"
   system "compass compile --css-dir #{source_dir}/stylesheets"
   system "jekyll"
 end
</code></pre>

<p> e. 经过上面的修改之后，浏览器本地预览的时候图片显示就正常了。在<code>rake deploy</code>阶段，脚本会把<code>public</code>目录下的图片拷贝到<code>_deploy</code>目录，并更新到github服务器。这个过程是脚本完成的，我们不需要参与。<br/>
 f. 至此，本地图片预览处理的整个流程完成。</p></li>
<li><p>MinGW中文支持<br/>
 a.进入RailsInstaller下的Git\etc目录。<br/>
 b.编译<code>profile</code>文件，添加如下内容</p>

<pre><code> export LANG=en
 alias l='/bin/ls --show-control-chars --color=auto'
 alias la='/bin/ls -aF --show-control-chars --color=auto'
 alias ll='/bin/ls -alF --show-control-chars --color=auto'
 alias ls='/bin/ls --show-control-chars --color=auto'
</code></pre>

<p> c. 修改inputrc文件，修改如下:</p>

<pre><code> # disable/enable 8bit input
 set meta-flag on
 set input-meta on
 set output-meta on
 set convert-meta off
</code></pre></li>
<li><p>设置git commit 编辑器<br/>
 运行命令<code>git config --global core.editor notepad.exe</code>,即可设置记事本为编辑器.</p></li>
<li><p>Bug</p>

<ol>
<li><code>&lt;!-- more --&gt;</code>后面接代码区块存在一些问题，具体原因不清楚。</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Octopress建Blog(基础篇)]]></title>
    <link href="http://yoursite.com/blog/2012/12/27/octopress-base/"/>
    <updated>2012-12-27T11:38:00+08:00</updated>
    <id>http://yoursite.com/blog/2012/12/27/octopress-base</id>
    <content type="html"><![CDATA[<ol>
<li><p>安装railsinstaller.<br/>
 点击<a href="http://railsinstaller.org/">这里</a>到官方网站下载软件.railsinstaller包含了ruby,rails,bundle等一系列工具，具体可以看官方网站的说明。安装过程比较简单，就是不断的Next,除了安装路径，其他使用默认设置即可。</p></li>
<li><p>配置rails环境<br/>
 在安装railsinstaller的最后一步，有一个配置项，提示用户是否进入rails环境配置，此配置项默认情况下是选中的。如果进入了rails配置环境，用户需要输入自己的用户名和邮箱，输入完成之后，程序自动生成一个ssh_key,放在用户目录的.ssh子目录下。<!-- more -->运行过程的相关信息如下：</p>

<pre><code> # Rails Environment Configuration.

 Your git configuration is incomplete.
 user.name and user.email are required for properly using git and services such
 as GitHub ( http://github.com/ ).

  Please enter your name, for example mine is: Wayne E. Seguin
 name &gt; xxxxxxx
 Setting user.name to xxxxxxx

  Please enter your email address, for example mine is: wayneeseguin@gmail.com
 email &gt; xxxxxxx@gmail.com
 Setting user.email to xxxxxxx@gmail.com

 ---
 git:
   user.name:  xxxxxxx
   user.email: xxxxxxx@gmail.com
   version:    git version 1.7.9.msysgit.0

 ruby:
   bin:        D:/RailsInstaller/Ruby1.9.2/bin/ruby.exe
   version:    ruby 1.9.3p125 (2012-02-16) [i386-mingw32]

 rails:
   bin:        D:/RailsInstaller/Ruby1.9.2/bin/rails.bat
   version:    Rails 3.2.1

 ssh:
   public_key_location: C:\Users\xxxxxxx/.ssh/id_rsa.pub
   public_key_contents: ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA0u36KdY6zTS3RpLO1C6Gh
 tVr3ELzYRhGzjU2vcxXdGdAeLrLPfN7G6aUQ65qrW3pTwb8zcZrrEmdhx2/xV3mkAFiE5riB2ZGLw2se
 pRZdnmkiyULV33c51KYsltyO6F37RWtdbAQA2OjPNGuTL+DtxwmdDeObUjKJjkt8RxFtWqCJ0TqH+aMw
 r+MPycNxSamk1Ady5DySM5EH8YTbchD+GFU93VWRAFpydTy8ZAWhlx4PsBoWbONzrlhtqjovNsKRw5VH
 atk58hxsp1HPRR5XvF0LYd401QiwArDuw/m41rhrp8CyMzb0dTOQGxfl3ckNmcBovjSyaqbVYkY32Crm
 Q== xxxxxxx &lt;xxxxxxx@gmail.com&gt;

 C:\Sites&gt;
</code></pre>

 这里要说明几点:

<ul>
<li>C:\Users\xxxxxxx/.ssh/id_rsa.pub是ssh的公匙，对应的私匙是同样目录下的id_rsa文件.</li>
<li>安装完成之后，如果要执行相关命令,我们可以通过<code>开始菜单--&gt;railsinstaller--&gt;git bash</code>来进入bash窗口,输入命令。</li>
<li>Windows路径的访问，比如<code>c:\Sites</code>,在bash下对应的是<code>/c/Sites</code>.</li>
</ul>
</li>
<li><p>配置Gems源<br/>
 把默认的Gems源改成ruby.taobao.com</p>

<pre><code> C:\Sites&gt;gem source -l
 *** CURRENT SOURCES ***

 http://rubygems.org/

 C:\Sites&gt;gem source -r http://rubygems.org/
 http://rubygems.org/ removed from sources

 C:\Sites&gt;gem source -a http://ruby.taobao.org
 http://ruby.taobao.org added to sources

 C:\Sites&gt;gem source -l
 *** CURRENT SOURCES ***

 http://ruby.taobao.org

 C:\Sites&gt;   
</code></pre></li>
<li><p>创建github库</p>

<ul>
<li>创建github非常简单，需要注意的是库名最好是Username.github.com的形式。这样的话，我们就可以通过http://Username.github.com的URL访问BLOG了。 <br/>
  <img src="http://yoursite.com/images/pic/octopress_base_github_new.png" alt="" /><br/>
  图片中的叹号表明我已经创建了此库，不能再次创建。</li>
<li>添加SSH Public_key<br/>
  a. 点击右上角的<code>account setting</code>按钮,进入setting页面。接着点击页面中的ssh keys按钮，添加一个SSH key。然后把上面的id_rsa.pub文件中的内容拷贝到Key框中，如下图所示，接着点击<code>Add Key</code>按钮,按照提示输入github账户的密码，SSH Key加入成功。<br/>
  <img src="http://yoursite.com/images/pic/octopress_base_sshkey_add.png" alt="" /></li>
</ul>
</li>
<li><p>下载Octopress源码<br/>
 点击<a href="http://octopress.org/">这里</a>到官方网站,点击<a href="https://github.com/imathis/octopress">这里</a>下载相关源代码。下载好源代码后,运行git bash,进入源码根目录，后续的操作都在此环境下进行。</p></li>
<li><p>下载Octopress的依赖包</p>

<ul>
<li>修改根目录下Gemfile文件，将数据源改成source &#8220;http://ruby.taobao.org&#8221;</li>
<li>运行bundle install 命令,然后等待依赖包更新完成(有些网上教程说用bundle update,最好不要这样。因为update使用最新的包，在ruby世界，最新的不一定是匹配的)。</li>
</ul>
</li>
<li><p>安装主题<br/>
 运行rake install.此命令就是把主题拷贝到相应的位置，下面是运行的输出结果。</p>

<pre><code> ## Copying classic theme into ./source and ./sass
 mkdir -p source
 cp -r .themes/classic/source/. source
 mkdir -p sass
 cp -r .themes/classic/sass/. sass
 mkdir -p source/_posts
 mkdir -p public
</code></pre></li>
<li><p>用git管理<em>posts目录<br/>
 在安装完主题后，系统会自动创建一个空目录source/</em>posts，以后创建的文章都会保存在这个目录内,我们需要对它用Git进行管理.</p>

<ul>
<li><p>初始化版本库.</p>

<blockquote><p>$ cd source/_posts/<br/>
$ git init<br/>
$ touch README.md<br/>
$ git add *<br/>
$ git commit -m &#8220;first commit&#8221;</p></blockquote></li>
<li><p>备份到github</p>

<blockquote><p>$ git remote add origin git@github.com:[Username]/[Repository].git<br/>
$ git checkout -b md<br/>
$ git push origin md</p></blockquote></li>
</ul>
</li>
<li><p>生成Blog文件<br/>
 现在回到Octopress的根目录，运行下面命令</p>

<blockquote><p>$ rake generate</p></blockquote></li>
<li><p>本地测试</p>

<ul>
<li><p>启动rake服务:</p>

<blockquote><p>$ rake preview</p></blockquote></li>
<li><p>打开网页,输入localhost:4000,如果一切正常，你将会看到你的BLOG首页了。当然，首页除了框架，什么内容都没有.</p></li>
</ul>
</li>
<li><p>Blog同步到github.</p>

<ul>
<li>指定github库的URL,运行命令

<blockquote><p>$ rake setup_github_pages</p></blockquote></li>
</ul>


<p>  然后会提示你输入github的URL，此URL和上面的“git remote add origin git@github.com:[Username]/[Repository].git&#8221;是一样的。</p>

<pre><code> windows下可能会在My Octopress Page is coming soon之后出现hellip;不是内部命令之类的错误, 可以不用管.
 如果一定不想要出现这个错误可以修改myoctopress目录下的Rakefile, 搜My Octopress Page is coming soon,
 在…前加个(这个是Windows cmd的转义符), 如下
 system “echo ‘My Octopress Page is coming soon ^…’ &gt; index.html” rake setup_github_pages
 命令最后出现Now you can deploy to xxxxxxx with rake deploy, 就表示成功.
</code></pre>

<ul>
<li><p>同步到github,运行命令</p>

<blockquote><p>$ rake deploy</p></blockquote></li>
<li><p>如果一切正常，等上10分钟左右，根据你github库的URL地址输入对应的http地址，就会看到效果了。<br/>
  a.如果你创建库的URL形式是git@github.com:[Username]/[Username].github.com.git,</p>

<pre><code>   blog的http地址就是http://Username.github.com  
</code></pre>

  b.如果库是非a形式的URL git@github.com:[Username]/[Repository].git

<pre><code>   blog的http地址就是http://Username.github.com/Repository
</code></pre>

<p>  c.绑定自己的域名，这个就不在讨论范围之内了。</p></li>
</ul>
</li>
<li><p>添加第一篇文章</p>

<ul>
<li>OctoPress的文章默认是用Markdown写的，具体教程点击<a href="http://wowubuntu.com/markdown/">这里</a></li>
<li>我是使用markdownpad工具来书写Marddown的，工具的下载点击<a href="http://markdownpad.com/">这里</a></li>
<li><p>运行<code>rake new_post["Hello World"]</code>,会在source/_posts目录下生成一个markdown文件。</p>

<blockquote><p>Creating new post: source/_posts/2012-12-27-hello-world.markdown</p></blockquote></li>
<li><p>随便在markdown文件上写点东西，如果有中文，会导致错误，解决方法请看下面内容。</p></li>
<li>运行<code>rake generate</code>。</li>
<li>如果生成成功， 接着运行<code>rake preview</code>,在浏览器上输入<code>localhost:4000</code>就可以看到你的第一篇文章了。</li>
</ul>
</li>
<li><p>加入Octopress对中文的支持<br/>
 Octopress默认情况下是不支持中文的，如果你的Markdown文件中包含有中文字符，在<code>rake generate</code>阶段会导致生成错误，要解决这个问题，运行下面命令</p>

<blockquote><p>$ cd<br/>
$ echo &#8220;export LC_ALL=en_US.UTF-8&#8221; > .bash_profile<br/>
$ echo &#8220;export LANG=en_US.UTF-8&#8221; >> .bash_profile</p></blockquote>

<p> 完成之后，关闭并重进bash即可。</p></li>
<li><p>总结</p>

<ol>
<li>执行rake new_post[&#8216;title&#8217;]来生成一个博文；</li>
<li>找对生成的markdown文件，编辑内容；</li>
<li>执行rake generate来生成文章；</li>
<li>执行rake preview在本地预览；</li>
<li>执行rake deploy发布到Github中。</li>
<li>执行下面命令将修改的源码推送到source分支：

<blockquote><p>git add .<br/>
git commit -m “your message”<br/>
git push origin source</p></blockquote></li>
</ol>
</li>
<li><p>参考文章</p>

<ul>
<li><a href="http://mrzhang.me/blog/blog-equals-github-plus-octopress.html">Blog = GitHub + Octopress</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">搭建一个免费的，无限流量的Blog&#8212;-github Pages和Jekyll入门</a></li>
<li><a href="http://yanping.me/cn/blog/2012/03/18/github-pages-step-by-step/#ruby">Github Pages极简教程</a></li>
<li><a href="http://wowubuntu.com/markdown/">Markdown 语法说明</a></li>
<li><a href="http://www.yangzhiping.com/tech/r-markdown-knitr.html">为什么Markdown+R有较大概率成为科技写作主流</a></li>
<li><a href="http://yanping.me/cn/blog/2012/10/09/chinese-charset-problems-with-jekyll/">在Windows下使用jekyll如何避免出现中文字符集错误</a></li>
<li><a href="http://jenwang.org/blog/2013/01/23/how-to-octopress/">How-to-octopress</a></li>
<li><a href="http://www.cnblogs.com/oec2003/archive/2013/05/27/3100896.html">Windows下搭建Octopress博客</a></li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
</feed>
